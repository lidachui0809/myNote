# 数据结构

1. ## 基本概念

   1. 数据项：是构成数据元素的最小单位；
   2. 数据元素：是数据的基本单位，通常作为一个整体进行考虑；
   3. 数据对象：具有相同性质的数据元素的集合；
   4. 数据结构：相互之间存在一种或者多种关系；

2. ## 数据结构三要素

   1. ![](D:\李Da锤\note\Image\数据结构三要素.png)

   2. 数据的存储结构
      ![](D:\李Da锤\note\Image\数据存储结构.png)

      1. 顺序存储：逻辑上位置相邻的数据也存储再物理位置相邻的存储单元之中；
      2. 链式存储：逻辑上相邻的元素在物理位置上也可也不相邻，可以通过存储地址的指针来表示关系；
      3. 索引存储：再存储信息的同时，建立索引表，通过索引或关键字来表示元素之间的先后顺序；
      4. 哈希/散列存储：根据元素关键字，直接计算出元素地址；

   3. ## 算法

      1. 空间复杂度
      2. 时间复杂度( T(n)  n表示问题规模)
         <img src=".\Image\算法时间复杂度.png" style="zoom:200%;" />
         1. T(n)=O(n)；T(n)=O(n平方)；
   
   4. ## 线性表![](.\Image\线性表.png)
   
      1. 顺序表 ![](D:\李Da锤\note\Image\顺序表总结.png)
         使用malloc函数开辟地址，并且可以返回一个指向该地址收首位的指针，用free函数可以释放指针指向的某篇区域的地址；
   
      2. 单链表
         ![](D:\李Da锤\note\Image\单链表定义.png)
   
         1. 代码示例：
   
            ```c
            #include <stdio.h>
            #include<stdlib.h> //导入函数库 
            #define InitSize 5
            
            typedef struct LNode{
            	int data;
            	struct LNode *next;
            	//定义一个可以指向LNode类型的指针类型; 用于指向下一个节点； 
            }LNode,*LinkList;
            
            
            void InitList(LinkList &list){
            	list=(LNode *)malloc(sizeof(LNode));//在这里添加一个表头 
            	list->next=NULL;
            	list->data=NULL;
            }
            
            void printfData(LinkList &list){
            	LNode *p=list->next;
            	printf(" 打印值 p:%d \n",p->data);	
            	int i=1;
            	while(p!=NULL){
            		printf("第%d个链表值为p.next :%d p.data:%d p的地址为：%d \n",i++,p->next,p->data,p);
            		p=p->next;
            	}
            }
            
            
            void addData(LinkList &list){
            	LNode *p=list;
            	while(true){
            		int x;
            		printf("输入data值：\n");
            		scanf("%d",&x);
            		if(x==-1){
            			break;
            		}
            		LNode *s=(LNode *)malloc(sizeof(LNode));
            		s->data=x;
            		//s->next=p->next;
            		p->next=s;
            		s->next=NULL;
            		p=s;
            		printf("s的地址 s.next:%d p.next %d ;s.data: %d \n",s->next,p->next,s->data);
            	}
            	printfData(list);	
            }
            
            // s：新链表 p：需要插入的节点 
            //尾插法 
            LNode *insertBlack(LinkList &list,LNode *p){
            	LNode *s=list;
            	printf("list.next:%d p.next:%d p.data:%d \n",list->next,p->next,p->data);
            	if(p==NULL||s==NULL)
            		return NULL;
            	p->next=s->next;  //将原先的值滞空； 
            	s->next=p;
            //	s=p;
            	return s;
            }
            
            //链表转置 
            void reverseList(LinkList &list){
            	LNode *p=list->next;
            	LinkList newL;//建立一个新链表来保存数据 
            	InitList(newL);
            	LNode *s=newL;//建立一个新节点，用来添加链表 
            	int count=0;
            	while(p!=NULL){
            		printf("p.data值:%d \n",p->data);
            		//重新开辟一个节点 防止插入时链表指向被修改； 
            		LNode *p1=(LNode *)malloc(sizeof(LNode));
            		p1->data=p->data;
            		p1->next=p->next;
            		insertBlack(s,p1); 
            		p=p->next;//插入完成 指针下移； 
            		count++;
            	}
            	printf("总共添加了count:%d \n",count);
            	printf("打印制换后得值:\n");
            	printfData(newL);
            }
            
            
            
            void inputData(LinkList &list){
            	int x;
            	scanf("%d",x);
            	while(x==-1){
            		LinkList nlist=(LNode *)malloc(sizeof(LNode));
            		//这里也可以用LNode * 用LinkList只是为了表示这是链表; 
            		nlist->data=x;
            		list->next=nlist;//将这个新的链表的地址赋给上一个list; 
            	}
            }
            
            bool insertData(LinkList &list,int indexOf,int vaule){
            	int j=1;//记录当前节点的位置;
            	LNode *p=list;
            	//这里只是将p移动到需要插入的位置 
            	while(p!=NULL&&j<indexOf-1){
            		p=p->next;
            		//这里链表头指向了第一个链表,所以p=p->next 就可以让p指向第一个链表的地址
            		// 进而获取到下一个链表的地址 
            		printf(" p.data:%d",p->data);
            		j++; 
            	}
            	if(p->next==NULL){
            		return false;
            	}
            	LNode *nList=(LNode *)malloc(sizeof(LNode));
            	nList->data=vaule;
            	nList->next=p->next;//将之前p中的所指向的链表地址赋值给插入的链表；
            	p->next=nList;//在将p指向新插入的地址;
            	return true;	
            }
            
            int getLength(LinkList &list){
            	int count=0;
            	LNode *p=list->next;
            	while(p!=NULL){
            		count++;
            		p=p->next;
            	}
            	return count;
            }
            
            LNode *getLNode(LinkList &list,int i){
            	LNode *p=list;
            	int j=0;
            	while(p!=NULL&&j<i){
            		p=p->next;
            		j++;
            		printf("j:%d",j);
            	}
            	return p;
            }
            
            LNode *getLNodeByV(LinkList &list,int vaule){
            	LNode *p =list->next;
            	while(p!=NULL&&p->data!=vaule){
            		p=p->next;
            	}
            	return p;
            }
            
            void deleteData(LinkList &list,int index){
            	LNode *p=list;
            	int j=1;
            	while(p->next!=NULL&&j<index-1){
            		p=p->next;
            		j++;
            	}
            	if(p->next==NULL)
            		return;
            	LNode *s=p->next;//获得需要删除的链表；
            	printf("当前删除第%d的链表，其data:%d",j+1,s->data);
            	p->next=s->next;//让p指向需要删除链表的next地址	
            	free(s);//释放删除的地址； 
            }
            
            int main(){
            	/* 
            	 	LinkList list2;//注意区分  这种写法表示这是一个链表
            	 	LNode *list2_1;//这个用来表示一个节点; 这两者本质是一样的，只		是命名不一样；
            	*/
            	LinkList list; 
            	InitList(list)
            	addData(list);
            	reverseList(list); 
            	return 0;
            }
            ```
   
      3. 双链表
   
         1. 双链表的出现是为了弥补单链表向上查找的不方便，其基本实现原里是通过定义一个前指针piror 和一个后指针 next ，用 p2.piror -> p1，用 p2.next -> p2，双指针；使得节点之间可以通过指针来获取；
   
         2. 插入与初始化操作
   
            ```c
            void initList(DLinkList &dlist){
            	dlist=(DLNode *)malloc(sizeof(DLNode));
            	dlist->next=NULL;
            	dlist->prior=NULL; 
            }//初始化方法基本一致
            
            //插入数据
            void insertData(DLinkList &dlist,int data){
            	DLNode *p=dlist;
            	DLNode *s=(DLNode *)malloc(sizeof(DLNode));
            	s->data=data;
            	//如果是第一个插入或者最后一个值 其后继节点可能为NULL 
            	//需要判断插入节点之前的那个链表是否存在后继节点 
            	if(p->next!=NULL){
            		s->next=p->next;
            		p->next->prior=s;
            	}
            	p->next=s;
            	s->prior=p;
            }
            
            ```
   
         3. 数据插入，这里使用了头插法；基本原理是将头节点的prior指向每次最后一次插入的节点，这样就可以通过头节点获取到最后一个节点，实现头插入；
   
            ```c
            void insertData(DLinkList &dlist,int data){
            	DLNode *p=dlist;
            	DLNode *q=dlist;
            	DLNode *s=(DLNode *)malloc(sizeof(DLNode));
            	s->data=data;
            	// 头插法 
            	if(p->prior!=NULL){
            		p=p->prior;//获取上一次最后一次插入的节点值 
            	}
            	s->next=p->next; 
            	p->next=s;
            	s->prior=p;	
            	q->prior=s;	//这里将头指针的prior指向了新插入的s; 就可以通过prior获取最后一次插入的节点，在通过该节点实现头插入 
            	
            	// 尾插法 顺序与输入相反 
            	/* 
            		s->next=p->next;
            		p->next=s;
            		s->prior=p;
            	*/
            	
            	//如果是插入在最后一个值 其后继节点可能为NULL 
            	//需要判断插入节点之前的那个链表是否存在后继节点 
            	if(p->next!=NULL){
            		p->next->prior=s;
            	}
            }
            ```
   
            
   